package datagen

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"sync"
	"time"

	"github.com/feliixx/mgodatagen/datagen/generators"
	"github.com/gosuri/uiprogress"
	"github.com/gosuri/uiprogress/util/strutil"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/bsontype"
)

type fileWriter struct {
	*baseWriter

	prettyPrint  bool
	out          io.Writer
	showProgress bool
}

func newFileWriter(options *Options, logger, out io.Writer) writer {

	w := &fileWriter{
		baseWriter: &baseWriter{
			batchSize:  1000,
			mapRef:     make(map[int][][]byte),
			mapRefType: make(map[int]bsontype.Type),
			logger:     logger,
		},
		prettyPrint: options.PrettyPrint,
		out:         out,
	}

	if out != os.Stdout && !options.Quiet {
		w.showProgress = true
	}
	return w
}

func (w *fileWriter) write(collections []Collection, seed uint64) (err error) {

	for i := 0; i < len(collections); i++ {

		ci := generators.NewCollInfo(collections[i].Count, []int{5, 0, 6}, seed, w.mapRef, w.mapRefType)

		// as the document is not inserted in mongodb, the "_id" won't be autogenerated
		// if not present, so add an objectId generator if user hasn't specified one
		_, hasId := collections[i].Content["_id"]
		if !hasId {
			collections[i].Content["_id"] = generators.Config{
				Type: generators.TypeObjectID,
			}
		}
		collections[i].docGenerator, err = ci.NewDocumentGenerator(collections[i].Content)
		if err != nil {
			return fmt.Errorf("fail to create DocumentGenerator for collection '%s'\n%v", collections[i].Name, err)
		}

		aggs, err := ci.NewAggregatorSlice(collections[i].Content)
		if len(aggs) > 0 || err != nil {
			return errors.New("Aggregators are not supported for stdout or file output")
		}
	}

	for i := 0; i < len(collections); i++ {
		w.generate(&collections[i])
	}
	return nil
}

func (w *fileWriter) generate(coll *Collection) {

	if w.showProgress {

		progress := uiprogress.New()
		progress.SetOut(w.logger)
		progress.SetRefreshInterval(50 * time.Millisecond)
		progress.Start()
		defer progress.Stop()

		w.progressBar = progress.AddBar(coll.Count).AppendCompleted().PrependFunc(func(b *uiprogress.Bar) string {
			stepName := "generating"
			if b.Current() == coll.Count {
				stepName = "done"
			}
			return strutil.Resize(fmt.Sprintf("collection %s: %s", coll.Name, stepName), 35)
		})
	}

	tasks := make(chan *rawChunk, 5)

	var wg sync.WaitGroup
	wg.Add(1)
	go w.writeToStdout(&wg, coll, tasks)

	w.generateDocument(context.Background(), tasks, coll.Count, coll.docGenerator)

	wg.Wait()
}

func (w *fileWriter) writeToStdout(wg *sync.WaitGroup, coll *Collection, tasks <-chan *rawChunk) {

	defer wg.Done()

	buffer := bytes.NewBuffer(make([]byte, 0, 64000))

	// format is :
	//
	// {
	//   "dbName.collectionName": [
	//	   {...},
	//	   {...},
	//	   {...}
	//   ]
	// }
	buffer.WriteByte('{')
	buffer.WriteByte('\n')
	fmt.Fprintf(buffer, `  "%s.%s": [`, coll.DB, coll.Name)
	buffer.WriteByte('\n')

	prefix := "    "

	for t := range tasks {

		for _, doc := range t.documents[:t.nbToInsert] {

			raw := bson.Raw(doc)

			buffer.Write([]byte(prefix))
			if w.prettyPrint {
				bson.IndentExtJSON(buffer, []byte(raw.String()), prefix, "  ")
			} else {
				buffer.Write([]byte(raw.String()))
			}
			buffer.WriteByte(',')
			buffer.WriteByte('\n')

			if buffer.Len() > 64000 {
				w.out.Write(buffer.Bytes())
				buffer.Reset()
			}
		}
		pool.Put(t)
	}

	// remove the last trailing comma
	buffer.Truncate(buffer.Len() - 2)

	buffer.WriteByte('\n')
	buffer.WriteByte(' ')
	buffer.WriteByte(' ')
	buffer.WriteByte(']')
	buffer.WriteByte('\n')
	buffer.WriteByte('}')

	if buffer.Len() > 0 {
		w.out.Write(buffer.Bytes())
	}
}

package datagen

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"sync"
	"time"

	"github.com/feliixx/mgodatagen/datagen/generators"
	"github.com/gosuri/uiprogress"
	"github.com/gosuri/uiprogress/util/strutil"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/bsontype"
)

type fileWriter struct {
	*basicGenerator

	prettyPrint  bool
	out          io.Writer
	showProgress bool
}

func newFileWriter(options *Options, logger, out io.Writer) writer {

	w := &fileWriter{
		basicGenerator: &basicGenerator{
			batchSize:  1000,
			mapRef:     make(map[int][][]byte),
			mapRefType: make(map[int]bsontype.Type),
			logger:     logger,
		},
		prettyPrint: options.PrettyPrint,
		out:         out,
	}

	if out != os.Stdout && !options.Quiet {
		w.showProgress = true
	}
	return w
}

func (w *fileWriter) write(collections []Collection, seed uint64) (err error) {

	for i := 0; i < len(collections); i++ {

		ci := generators.NewCollInfo(collections[i].Count, []int{5, 0, 6}, seed, w.mapRef, w.mapRefType)

		// as the document is not inserted in mongodb, the "_id" won't be autogenerated
		// if not present, so add an objectId generator if user hasn't specified one
		_, hasId := collections[i].Content["_id"]
		if !hasId {
			collections[i].Content["_id"] = generators.Config{
				Type: generators.TypeObjectID,
			}
		}
		collections[i].docGenerator, err = ci.NewDocumentGenerator(collections[i].Content)
		if err != nil {
			return fmt.Errorf("fail to create DocumentGenerator for collection '%s'\n%v", collections[i].Name, err)
		}
	}

	for i := 0; i < len(collections); i++ {
		w.generate(&collections[i])
	}
	return nil
}

func (w *fileWriter) generate(coll *Collection) {

	if w.showProgress {

		progress := uiprogress.New()
		progress.SetOut(w.logger)
		progress.SetRefreshInterval(50 * time.Millisecond)
		progress.Start()
		defer progress.Stop()

		w.progressBar = progress.AddBar(coll.Count).AppendCompleted().PrependFunc(func(b *uiprogress.Bar) string {
			stepName := "generating"
			if b.Current() == coll.Count {
				stepName = "done"
			}
			return strutil.Resize(fmt.Sprintf("collection %s: %s", coll.Name, stepName), 35)
		})
	}

	tasks := make(chan *rawChunk, 5)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(1)
	go w.writeToStdout(ctx, cancel, &wg, coll, tasks)

	w.generateDocument(ctx, tasks, coll.Count, coll.docGenerator)

	wg.Wait()
}

func (w *fileWriter) writeToStdout(ctx context.Context, cancel context.CancelFunc, wg *sync.WaitGroup, coll *Collection, tasks <-chan *rawChunk) {

	defer wg.Done()

	buffer := bytes.NewBuffer(make([]byte, 0, 64000))
	fmt.Fprintf(buffer, `{
  "%s.%s": [
`, coll.DB, coll.Name)

	prefix := "    "

	for t := range tasks {
		// if an error occurs in one of the goroutine, 'return' is called which trigger
		// wg.Done() ==> the goroutine stops
		select {
		case <-ctx.Done():
			return
		default:
		}

		for _, doc := range t.documents[:t.nbToInsert] {

			raw := bson.Raw(doc)

			buffer.Write([]byte(prefix))
			if w.prettyPrint {
				bson.IndentExtJSON(buffer, []byte(raw.String()), prefix, "  ")
			} else {
				buffer.Write([]byte(raw.String()))
			}
			buffer.WriteByte(',')
			buffer.WriteByte('\n')

			if buffer.Len() > 64000 {
				w.out.Write(buffer.Bytes())
				buffer.Reset()
			}
		}
		pool.Put(t)
	}

	// remove the last trailing comma
	buffer.Truncate(buffer.Len() - 2)
	fmt.Fprintln(buffer, `
  ]
}`)

	if buffer.Len() > 0 {
		w.out.Write(buffer.Bytes())
	}
}
